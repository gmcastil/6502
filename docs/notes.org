* Conventions
** Numerical Consistency
- In general, use 16'd1 or 16'd3 for actions that inrement or change multi-bit
  signals (e.g., incrementing the PC)
- Use 1'b1 or 1'b0 for one-bit signals (e.g., processor status flag)
** Addressing Modes
- Every addressing mode has a distinct path through the state machine (e.g.,
  only opcodes in the absolute-addressing family appear in the execution of that
  set of states in the FSM, such as ABS_1)
- Two-cycle instructions are exceptions to this rule
** Coding Conventions
- The PC should be incremented on the rising edge of the state immediately
  before the FETCH state
- Updaes to the processor status flags and the accumulator are registered on the
  rising edge of clock while in hte FETCH state.
- Increment PC immediately prior to returning to the FETCH state (e.g., on the
  rising edge of the clock during the state immediately prior to FETCH.
- Register ALU results and processor status flags on the return to the FETCH
  state (i.e., the rising edge of clock in the state prior to FETCH). This means
  registering the new value on the preceeding state of the FSM.
- When using the ALU with the accumulator, A should be placed on the AI input
  with X, Y, or memory on the BI input.  This should simplify implementation and
  make it easier on the synthesis engine.
- Any instruction implementation that uses the accumulator should explicitly set
  the update_accumulator flag to 1 or 0 depending upon whether an instruction
  affects the accumulator.
* Arithmetic Logic Unit (ALU)
** Operations
*** Addition (3'b000)
*** Boolean OR (3'b001)
*** Boolean XOR (3'b010)
*** Boolean AND (3'b011)
*** Shift Right (3'b100)
** Flags
*** Overflow (OVF)
*** Carry (CARRY)
** Instructions
