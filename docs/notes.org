* Conventions
** Numerical Consistency
- In general, use 16'd1 or 16'd3 for actions that inrement or change multi-bit
  signals (e.g., incrementing the PC)
- Use 1'b1 or 1'b0 for one-bit signals (e.g., processor status flag)
** Addressing Modes
- Every addressing mode has a distinct path through the state machine (e.g.,
  only opcodes in the absolute-addressing family appear in the execution of that
  set of states in the FSM, such as ABS_1)
- Two-cycle instructions are exceptions to this rule
** Coding Conventions
- The PC should be incremented on the rising edge of the state immediately
  before the FETCH state
- Updaes to the processor status flags and the accumulator are registered on the
  rising edge of clock while in hte FETCH state.
- Increment PC immediately prior to returning to the FETCH state (e.g., on the
  rising edge of the clock during the state immediately prior to FETCH.
- Register ALU results and processor status flags on the return to the FETCH
  state (i.e., the rising edge of clock in the state prior to FETCH). This means
  registering the new value on the preceeding state of the FSM.
- When using the ALU with the accumulator, A should be placed on the AI input
  with X, Y, or memory on the BI input.  This should simplify implementation and
  make it easier on the synthesis engine.
- Any instruction implementation that uses the accumulator should explicitly set
  the update_accumulator flag to 1 or 0 depending upon whether an instruction
  affects the accumulator.
* Arithmetic Logic Unit (ALU)
** Operations
*** Addition (3'b000)
*** Boolean OR (3'b001)
*** Boolean XOR (3'b010)
*** Boolean AND (3'b011)
*** Shift Right (3'b100)
** Flags
*** Overflow (OVF)
*** Carry (CARRY)
** Instructions
* Simulations
** ALU Simulation
To run the ALU simulation from a bash shell, change to the /6502/sim directory
and run the alu_sim.sh script.  This will call the alu_sim.tcl script which
simulates the ALU testbench and RTL.  Each operation supported by the ALU will
be checked and verified by the simulator with a series of pass / fail results
being echoed to the console.  Note that no waveforms will be generated.

*** Logic for testing the ALU addition function

#+HEADER: :exports both :results output
#+BEGIN_SRC python
for A in range(0, 256):
    for B in range(0, 256):
        carry_in = 1
        # Add with carry
        C, carry_out, overflow = add(A, B, carry_in)
        if not A[7] and not B[7] and carry_in:
            assert C[7] == 1
            assert overflow == 1
            assert carry_out == 0
        else if A[7] and B[7] and not carry_in:
            assert C[7] == 0
            assert overflow == 1
            assert carry_out == 1
        else:
            assert overflow == 0

        assert C == A + B
        if C > 255:
            assert carry_out == 1
#+END_SRC



** Processor Simulation
Because this is still very much under development, processor simulation is a bit
more involved.  The general idea is the following:
- For each addressing mode, the following files will be created:
  * A testbench incorporating the name of the addressing mode (e.g.,
    absolute_tb.v)
  * A 6502 assembly language source file in //roms/ (e.g., absolute.asm)
  * A simulation script in //sim/ (e.g., absolute_sim.tcl)
- To run a simulation from a bash shell, change to the /6502/sim directory and
  run the proc_sim.sh script with the appropriate addressing mode as the first
  command line argument.
- I still have no idea how I want to verify that the design is working as it
  should, but this is my first cut for now.
- Also, for now, each addressing mode will be tested and verified independently.
  Eventually, I want the default behavior to be running a comprehensive
  testbench that tests everything.
